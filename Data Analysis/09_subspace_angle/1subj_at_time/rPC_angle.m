function [angles, dom, rPCs] = rPC_angle(struct_rPCA, nsubj, sel_rPC, mean_posture)
%RPC_SINGLE_ANGLE
%		This function computes the angle between the subspace generated by 
%		the specified rPCs and the subspace of selected PC of the mean 
%		postures among all subjects.
%
%		Input:
%		struct_rPCA		generated structed of rPCA results by
%						function: struct_rPCA = rpca_all_subj(ngroup)
%		nsubj			subject number
%		sel_rPC			vector cointaint which rPC we want to include in
%						the generated subspace
%		mean_posture	mean posture computed among all subjects
%
%		Output
%		angles			angle between subspaces[grad];(nrPC x nsamples x 2)
%		dom				flag for the affected side of specified subj:
%						-1 h, 0 non dom affected, 1 dom affected
%		rPCs			(njoints x nrPC x nsamples x 2)

%% general parameter (to edit for displaying different rPCs)

t0			= 1;								% initial time of recorded trial
tf			= size(struct_rPCA(1).h.coeff,3);	% final time of recorded trial
njoint		= size(struct_rPCA(1).h.coeff,1);	% number of joint
nrpc_tot	= size(struct_rPCA(1).h.coeff,2);	% total number of used rPCs
nsamples	= tf - t0 + 1;						% number of samples
nrPC		= length(sel_rPC);					% how many rPCs we want as subspace base


%{
% PCA of mean postures, used to comparison

% creating empty matrices to fill up later
mean_mat	= [];
mean_mat_h	= [];
mean_mat_s	= [];
mean_mat_la = [];

% fai mean prima nel tempo per singolo soggetto, poi impili in gruppi di
% soggetti e poi fai la PCA tra i mean postures dei gruppi, svincoli dal
% tempo
for i = [1:10,12:20,22:24]
	if i < 6
		mean_mat_h	= cat(2 , mean_mat_h, mean(struct_rPCA(i).h.mean, 2));
	else
		mean_mat_s	= cat(2 , mean_mat_s, mean(struct_rPCA(i).s.mean, 2));
		mean_mat_la	= cat(2 , mean_mat_la, mean(struct_rPCA(i).la.mean, 2));
	end
end

% qua fai tutti i soggetti insieme per avere un'unica PCA di riferimento
% finale
mean_mat = [mean_mat_h, mean_mat_s, mean_mat_la];

% pca
% transpose because for pca rows are observations
% [coeff_h,	~,~,~,	var_expl_h,		~] = pca(mean_mat_h');
% [coeff_s,	~,~,~,	var_expl_s,		~] = pca(mean_mat_s');
% [coeff_la,	~,~,~,	var_expl_la,	~] = pca(mean_mat_la');
[coeff_all,	~, ~, ~, ~, ~] = pca(mean_mat');

% obs: there are more subj for s and la, coeff_all could be affected by it!
% angle_mean_h_all	= subspace(coeff_all(:,1),	coeff_h(:,1))	/pi*180;
% angle_mean_s_all	= subspace(coeff_all(:,1),	coeff_s(:,1))	/pi*180;
% angle_mean_la_all	= subspace(coeff_all(:,1),	coeff_la(:,1))	/pi*180;
% angle_mean_la_s		= subspace(coeff_s(:,1),	coeff_la(:,1))	/pi*180;
% angle_mean_la_h		= subspace(coeff_h(:,1),	coeff_la(:,1))	/pi*180;
% angle_mean_s_h		= subspace(coeff_s(:,1),	coeff_h(:,1))	/pi*180;

% choice of mean posture to compute angle
mean_posture = coeff_all(:, sel_rPC);
%}
mean_posture = mean_posture(:, sel_rPC);
%% subspace angle calculation
% check subj
if floor(nsubj)-nsubj ~= 0
	error('Ciao Giuseppe!')
elseif nsubj <= 0 || nsubj > 24
	error('this subject does not exist inside the dataset, number must be in [1 24]')
end


% iteration
if nsubj > 5 
	%% strokes subject
	
	% prealloc
	rPC_coeff_s		= zeros(njoint, nrPC, nsamples);
					% store matrix of each selected rPC in time stroke arm
	rPC_coeff_la	= zeros(njoint, nrPC, nsamples);
					% store matrix of each selected rPC in time LA arm
	angles			= zeros(nrPC, nsamples, 2);
					% angles between the two subspaces, 
					%		in dim 3.1 stroke-arm		vs mean_posture
					%		in dim 3.2 LA-arm			vs mean_posture
	
	% time iteration
	for i = t0 : tf
		[coeff_rPCs, ~, ~, dom] = rPC_t_subj(i, struct_rPCA, nsubj, sel_rPC);
	
		% stroke side
		coeff_s_tmp			= coeff_rPCs(:, :, 1);
		angles(:, i, 1)		= subspacea(mean_posture, coeff_s_tmp);
		rPC_coeff_s(:,:,i)	= coeff_s_tmp;
		
		% less affected side
		coeff_la_tmp		= coeff_rPCs(:, :, 2);
		angles(:, i, 2)		= subspacea(mean_posture, coeff_la_tmp);
		rPC_coeff_la(:,:,i)	= coeff_la_tmp;
		
	end
	
	% output section
	rPCs = zeros(njoint, nrPC, nsamples, 2); % Achtung! 4 dim matrix!
	rPCs(:, :, :, 1) = rPC_coeff_s;
	rPCs(:, :, :, 2) = rPC_coeff_la;
	
else
	%% healthy subject
	
	% prealloc
	rPC_coeff_h		= zeros(njoint, nrPC, nsamples);
					% store matrix of each selected rPC in time healthy
	angles			= zeros(nrPC, nsamples);
					% angles between the two subspaces: 
					%		healthy arm	vs mean_posture

	% time iteration
	for i = t0 : tf
		[coeff_rPCs, ~, ~, dom] = rPC_t_subj(i, struct_rPCA, nsubj, sel_rPC);
	
		% stroke side
		coeff_h_tmp			= coeff_rPCs(:, :, 1);
		angles(:, i)		= subspacea(mean_posture, coeff_h_tmp);
		rPC_coeff_h(:,:,i)	= coeff_h_tmp;
		
	end
	
	% output section
	%rPCs = zeros(njoint, nrpc, nsample);
	rPCs = rPC_coeff_h;
end

angles = angles * 180 /pi;

%{
%%OLD extrapulation of dynamic rPCs about a subject and a group of tasks

% check subj
if floor(nsubj)-nsubj ~= 0
	error('Ciao Giuseppe!')
elseif nsubj <= 0 || nsubj > 24
	error('this subject does not exist inside the dataset, number must be in [1 24]')
end

% single subject loading
if nsubj > 5 
	% strokes subject
	rPC_coeff_s	= [];
	rPC_coeff_la	= [];

	for i = t0 : tf
		[coeff_rPCs, ~, ~, dom] = rPC_t_subj(i, struct_rPCA, nsubj, sel_rPC);

		rPC_coeff_s		= cat(2, rPC_coeff_s, coeff_rPCs(:, :, 1));
		rPC_coeff_la	= cat(2, rPC_coeff_la, coeff_rPCs(:, :, 2));
	end

else
	% healthy subject
	rPC_coeff_h			= [];

	for i = t0 : tf
		[coeff_rPCs, ~, ~, dom] = rPC_t_subj(i, struct_rPCA, nsubj, sel_rPC);

		rPC_coeff_h	= cat(2, rPC_coeff_h, coeff_rPCs(:, rPC));
	end
end
%% confronto rPCs statiche con rPCs dinamiche
if nsubj > 5 
	% strokes subject
	
	angle_s = [];
	angle_la = [];
	
	for i = t0 : tf
		angle_s		= cat(2, angle_s,	subspace(mean_posture, rPC_coeff_s(:, :, i))	/pi*180);
		angle_la	= cat(2, angle_la,	subspace(mean_posture, rPC_coeff_la(:, :, i))	/pi*180);
	end
		angle = [angle_s; angle_la];
else
	% healthy subject
	
	angle = [];
	
	for i = t0 : tf
		angle		= cat(2, angle,	subspace(mean_posture, rPC_coeff_h(:,i))	/pi*180);
	end
end


%}
end

