function [angles] = rPC_angle_group(struct_rPCA, sel_rPC, mean_posture)
%RPC_ANGLE_GROUP
%		This function computes the angle between the subspace generated by 
%		the specified rPCs and the subspace of selected PC of the mean 
%		postures among all subjects' groups.
%
%		Input:
%		struct_rPCA		generated structed of rPCA results by
%						function: struct_rPCA = rpca_hsla(ngroup)
%		sel_rPC			vector cointaint which rPC we want to include in
%						the generated subspace
%		mean_posture	mean posture used as a comparison 
%
%		Output:
%		angles			struct containg angle between subspaces[grad];(nrPC x nsamples x 2)
%						for the three subjects'groups

%% general parameter (to edit for displaying different rPCs)

t0			= 1;								% initial time of recorded trial
tf			= size(struct_rPCA.h.coeff,3);		% final time of recorded trial
njoint		= size(struct_rPCA.h.coeff,1);		% number of joint
nrpc_tot	= size(struct_rPCA.h.coeff,2);		% total number of used rPCs
nsamples	= tf - t0 + 1;						% number of samples
nrPC		= length(sel_rPC);					% how many rPCs we want as subspace base

sla_dom		= isfield(struct_rPCA, 's');		% 1 if h_s_la, 0 if h_d_nd

%% PCA of mean postures, used to comparison

mean_posture = mean_posture(:, sel_rPC);

%% subspace angle calculation
if sla_dom
% prealloc h_s_la

	rPC_coeff_h		= zeros(njoint, nrPC, nsamples);
					% store matrix of each selected rPC in time healthy
	rPC_coeff_s		= zeros(njoint, nrPC, nsamples);
					% store matrix of each selected rPC in time stroke arm
	rPC_coeff_la	= zeros(njoint, nrPC, nsamples);
					% store matrix of each selected rPC in time LA arm
	angles = struct;
	angles.h		= zeros(nrPC, nsamples);	%	healthy-arm		vs mean_posture
	angles.s		= zeros(nrPC, nsamples);	%	stroke-arm		vs mean_posture
	angles.la		= zeros(nrPC, nsamples);	%	LA-arm			vs mean_posture
					% angles between the two subspaces

	% time iteration
	for i = t0 : tf
		[coeff_rPCs, ~, ~] = rPC_t_group(i, struct_rPCA, sel_rPC);

		% healthy side
		angles.h(:, i)		= subspacea(mean_posture, coeff_rPCs.h) * 180 /pi;
		rPC_coeff_h(:,:,i)	= coeff_rPCs.h;

		% stroke side
		angles.s(:, i)		= subspacea(mean_posture, coeff_rPCs.s) * 180 /pi;
		rPC_coeff_s(:,:,i)	= coeff_rPCs.s;

		% less affected side
		angles.la(:, i)		= subspacea(mean_posture, coeff_rPCs.la) * 180 /pi;
		rPC_coeff_la(:,:,i)	= coeff_rPCs.la;
	end

	rPC_coeff		= struct;
	rPC_coeff.h		= rPC_coeff_h;
	rPC_coeff.s		= rPC_coeff_s;
	rPC_coeff.la	= rPC_coeff_la;
	
elseif ~sla_dom
% prealloc h_d_nd

	rPC_coeff_h		= zeros(njoint, nrPC, nsamples);
					% store matrix of each selected rPC in time healthy
	rPC_coeff_a_d	= zeros(njoint, nrPC, nsamples);
					% store matrix of each selected rPC in time stroke dom 
	rPC_coeff_la_d	= zeros(njoint, nrPC, nsamples);
					% store matrix of each selected rPC in time LA dom
	rPC_coeff_a_nd	= zeros(njoint, nrPC, nsamples);
					% store matrix of each selected rPC in time stroke non dom 
	rPC_coeff_la_nd	= zeros(njoint, nrPC, nsamples);
					% store matrix of each selected rPC in time LA non dom
					
	angles = struct;
	angles.h		= zeros(nrPC, nsamples);	%	healthy-arm		vs mean_posture
	angles.a_d		= zeros(nrPC, nsamples);	%	dom stroke		vs mean_posture
	angles.la_d		= zeros(nrPC, nsamples);	%	dom LA  		vs mean_posture
	angles.a_nd		= zeros(nrPC, nsamples);	%	non dom stroke	vs mean_posture
	angles.la_nd	= zeros(nrPC, nsamples);	%	non dom LA  	vs mean_posture
					% angles between the two subspaces

	% time iteration
	for i = t0 : tf
		[coeff_rPCs, ~, ~] = rPC_t_group(i, struct_rPCA, sel_rPC);

		% healthy side
		angles.h(:, i)		= subspacea(mean_posture, coeff_rPCs.h) * 180 /pi;
		rPC_coeff_h(:,:,i)	= coeff_rPCs.h;

		% dominant, stroke side
		angles.a_d(:, i)		= subspacea(mean_posture, coeff_rPCs.a_d) * 180 /pi;
		rPC_coeff_a_d(:,:,i)	= coeff_rPCs.a_d;

		% dominant, less affected side
		angles.la_d(:, i)		= subspacea(mean_posture, coeff_rPCs.la_d) * 180 /pi;
		rPC_coeff_la_d(:,:,i)	= coeff_rPCs.la_d;
		
		% non dominant, stroke side
		angles.a_nd(:, i)		= subspacea(mean_posture, coeff_rPCs.a_nd) * 180 /pi;
		rPC_coeff_a_nd(:,:,i)	= coeff_rPCs.a_nd;

		% non dominant, less affected side
		angles.la_nd(:, i)		= subspacea(mean_posture, coeff_rPCs.la_nd) * 180 /pi;
		rPC_coeff_la_nd(:,:,i)	= coeff_rPCs.la_nd;
	end

	rPC_coeff		= struct;
	rPC_coeff.h		= rPC_coeff_h;
	rPC_coeff.a_d	= rPC_coeff_a_d;
	rPC_coeff.la_d	= rPC_coeff_la_d;
	rPC_coeff.a_nd	= rPC_coeff_a_nd;
	rPC_coeff.la_nd	= rPC_coeff_la_nd;
end
end

function [coeff_rPCs, var_rPCs, scoresMm_rPCs] = rPC_t_group(t, data_groups, sel_rPC)
%RPC_T_GROUP extrapulates rPCs about three subjects' groups and a specific group of tasks at
%time t
%	input = 
%			t:				selected time 
%			data_groups:	rPCA structure results of a certain tasks group for
%								all subjects's groups
%			sel_rPC:		number of desired rPC
%	output = 
%			coeff_rPCs:		coeff of selected rPCs at time t
%			var_rPCs:		explained variance of selected rPCs at time t
%			scoresMm_rPCs:	max and min value of scores associated to a
%								subjects' group and an istant of time t among all trial executions

%% extrapulation
	sla_dom2		= isfield(data_groups, 's');		% 1 if h_s_la, 0 if h_d_nd
	
	if sla_dom2
		
		var_rPCs		= struct;
		var_rPCs.h		= data_groups.h.var_expl(sel_rPC,t);
		var_rPCs.s		= data_groups.s.var_expl(sel_rPC,t);
		var_rPCs.la		= data_groups.la.var_expl(sel_rPC,t);

		coeff_rPCs		= struct;
		coeff_rPCs.h	= data_groups.h.coeff(:,sel_rPC,t);
		coeff_rPCs.s	= data_groups.s.coeff(:,sel_rPC,t);
		coeff_rPCs.la	= data_groups.la.coeff(:,sel_rPC,t);

		scr_rPCs		= struct;
		scr_rPCs.h		= data_groups.h.scores(:,sel_rPC,t);
		scr_rPCs.s		= data_groups.s.scores(:,sel_rPC,t);
		scr_rPCs.la		= data_groups.la.scores(:,sel_rPC,t);

		scoresMm_rPCs	= struct;
		scoresMm_rPCs.h	= [max(scr_rPCs.h), min(scr_rPCs.h)]';
		scoresMm_rPCs.s	= [max(scr_rPCs.s), min(scr_rPCs.s)]';
		scoresMm_rPCs.la= [max(scr_rPCs.la), min(scr_rPCs.la)]';
		
	elseif ~sla_dom2
		
		var_rPCs		= struct;
		var_rPCs.h		= data_groups.h.var_expl(sel_rPC,t);
		var_rPCs.a_d	= data_groups.a_d.var_expl(sel_rPC,t);
		var_rPCs.la_d	= data_groups.la_d.var_expl(sel_rPC,t);
		var_rPCs.a_nd	= data_groups.a_nd.var_expl(sel_rPC,t);
		var_rPCs.la_nd	= data_groups.la_nd.var_expl(sel_rPC,t);

		coeff_rPCs		= struct;
		coeff_rPCs.h	= data_groups.h.coeff(:,sel_rPC,t);
		coeff_rPCs.a_d	= data_groups.a_d.coeff(:,sel_rPC,t);
		coeff_rPCs.la_d	= data_groups.la_d.coeff(:,sel_rPC,t);
		coeff_rPCs.a_nd	= data_groups.a_nd.coeff(:,sel_rPC,t);
		coeff_rPCs.la_nd= data_groups.la_nd.coeff(:,sel_rPC,t);

		scr_rPCs		= struct;
		scr_rPCs.h		= data_groups.h.scores(:,sel_rPC,t);
		scr_rPCs.a_d	= data_groups.a_d.scores(:,sel_rPC,t);
		scr_rPCs.la_d	= data_groups.la_d.scores(:,sel_rPC,t);
		scr_rPCs.a_nd	= data_groups.a_nd.scores(:,sel_rPC,t);
		scr_rPCs.la_nd	= data_groups.la_nd.scores(:,sel_rPC,t);


		scoresMm_rPCs		= struct;
		scoresMm_rPCs.h		= [max(scr_rPCs.h), min(scr_rPCs.h)]';
		scoresMm_rPCs.a_d	= [max(scr_rPCs.a_d), min(scr_rPCs.a_d)]';
		scoresMm_rPCs.la_d	= [max(scr_rPCs.la_d), min(scr_rPCs.la_d)]';
		scoresMm_rPCs.a_nd	= [max(scr_rPCs.a_nd), min(scr_rPCs.a_nd)]';
		scoresMm_rPCs.la_nd	= [max(scr_rPCs.la_nd), min(scr_rPCs.la_nd)]';
	end
end
