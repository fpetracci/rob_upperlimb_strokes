clear all
syms x_t x_t_dot y_t y_t_dot theta theta_dot phi phi_dot L L_dot real
syms  g b real
fprintf('lo stato iniziale considerato è \n:')
% L_dot = 0;
z_t = 0;
x0 = [0; 0; 0; 0; pi/4; pi/20; pi/4; pi/20; 2; 0]

%% grafici sistema
% filename = 'system_model.png';
% filename2 = 'system_state.png';
% y = imread(filename);
% y2 = imread(filename2);
% figure(1)
% imshow(y);
% figure(2)
% imshow(y2);

%% funzioni dinamica
x = [x_t; x_t_dot; y_t; y_t_dot; theta; theta_dot; phi; phi_dot; L ; L_dot]
fprintf('il sistema è dato da: \n')

f = [ x_t_dot;...
	  0;...
	  y_t_dot;...
	  0;...
	  theta_dot;...
	  -2*(L_dot/L)*theta_dot+0.5*phi_dot^2*sin(2*theta)-(g/L)*sin(theta) - b * theta_dot;...
	  phi_dot;...
	  -2*(L_dot/L)*phi_dot-2*phi_dot*theta_dot*cot(theta);...
	  L_dot;...
	  0]
g1 = [0;...
	  1;...
	  0;...
	  0;...
	  0;...
	  -cos(theta)*sin(phi)/L;...
	  0;...
	  -cos(phi)/(sin(theta)*L);...
	  0;...
	  0]
g2 = [0;...
	  0;...
	  0;...
	  1;...
	  0;...
	  -cos(theta)*cos(phi)/L;...
	  0;...
	  sin(phi)/(sin(theta)*L);...
	  0;...
	  0]
g3 = [0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  1]
G = [g1 g2 g3];
x_ball = x_t + L*sin(theta)*sin(phi)
y_ball = y_t + L*sin(theta)*cos(phi)
z_ball = z_t + L*cos(theta)

% USCITE
% y = [x_ball;y_ball; z_ball];
% y = [x_t; y_t; L]
% y = [x_ball; y_ball; theta];
% y = [theta;phi;L]
% y = [x_t; y_t; theta;phi;L]
y = [x_ball - x_t; y_ball - y_t; z_ball-z_t ]% x_t; y_t   % Pos Ball Relativa

[r_mimo,Lf_full_mimo, T, E] = relative_degree_mimo(f,G,y,x)
%% zero dinamica
syms z_1 z_2 z_3 z_4
zeta = [z_1; z_2; z_3; z_4];
U = -inv(E)*T;
U_1_2 = simplify(U(1:2,1));
PHI = [x_t;x_t_dot;y_t;y_t_dot;Lf_full_mimo];
X = [x; zeta]
%% calcolo trasformazione inversa
syms xi_1 xi_2 xi_3 xi_4 xi_5 xi_6

XI = [xi_1; xi_2; xi_3;xi_4;xi_5; xi_6]
% calcolo phi, theta ed L da xi_1,xi_3;xi_5 viene abbastanza semplice
phi = atan(xi_1/xi_3)
theta = atan(xi_3/(xi_5*cos(phi)))
L = xi_5/cos(theta)

% le dot vengono più complicate, ma prendendo i coefficienti che
% moltiplicano le derivate, si può vedere come un sistema lineare, ora
% prendiamo xi_2, xi_4, x_6
% xi_2 = L_dot*sin(phi)*sin(theta) + L*phi_dot*cos(phi)*sin(theta) + L*theta_dot*cos(theta)*sin(phi)
%	   = L_dot*alpha+phi_dot*beta+theta_dot*gamma
% xi_4 = L_dot*cos(phi)*sin(theta) + L*theta_dot*cos(phi)*cos(theta) - L*phi_dot*sin(phi)*sin(theta)
%	   = L_dot*a+phi_dot*b+theta_dot*c
% xi_6 = L_dot*cos(theta) - L*theta_dot*sin(theta)
%	   = L_dot*A+theta_dot*C
alpha = sin(phi)*sin(theta);	% L_dot
beta = L*cos(phi)*sin(theta);	% phi_dot
gamma = L*cos(theta)*sin(phi);	% theta_dot
a =	 cos(phi)*sin(theta);		% L_dot		
b = - L*sin(phi)*sin(theta);	% phi_dot
c = L*cos(phi)*cos(theta);		% theta_dot	
A = cos(theta);					% L_dot
C = -L*sin(theta);				% theta_dot

M = [alpha beta gamma;...
	a	b	c;...
	A	0	C]

B = [xi_2; xi_4; xi_6]
X = linsolve(M,B)
L_dot = simplify(X(1))
phi_dot = simplify(X(2))
theta_dot = simplify(X(3))
U_1_2 = [-(sin(phi)*(g*sin(theta) + L*b*theta_dot))/cos(theta)...;
		 -(cos(phi)*(g*sin(theta) + L*b*theta_dot))/cos(theta)];
U_1_2 = simplify(U_1_2);
%subs(U_1_2,XI,[0; 0; 0; 0; 0; 0]) error division by zero
 

%% Zero dinamica

syms x_t_ddot y_t_ddot L_ddot
u = [x_t_ddot; y_t_ddot; L_ddot]
upsi = T + E * u
upsi = simplify(upsi,5)

% creazione uspilon ingressi "linearizzati"
ddy1 = L_dot*(phi_dot*cos(phi)*sin(theta) + theta_dot*cos(theta)*sin(phi)) + phi_dot*(L_dot*cos(phi)*sin(theta) + L*theta_dot*cos(phi)*cos(theta) - L*phi_dot*sin(phi)*sin(theta)) + theta_dot*(L_dot*cos(theta)*sin(phi) + L*phi_dot*cos(phi)*cos(theta) - L*theta_dot*sin(phi)*sin(theta)) - L*cos(theta)*sin(phi)*(b*theta_dot - (phi_dot^2*sin(2*theta))/2 + (g*sin(theta))/L + (2*L_dot*theta_dot)/L) - L*cos(phi)*sin(theta)*(2*phi_dot*theta_dot*cot(theta) + (2*L_dot*phi_dot)/L) + ...
		(- cos(phi)^2 - cos(theta)^2*sin(phi)^2) * u(1,:) +...
		(cos(phi)*sin(phi) - cos(phi)*cos(theta)^2*sin(phi)) * u(2,:) + ...
		sin(phi)*sin(theta) * u(3,:);

ddy2 = L_dot*(theta_dot*cos(phi)*cos(theta) - phi_dot*sin(phi)*sin(theta)) - theta_dot*(L*phi_dot*cos(theta)*sin(phi) - L_dot*cos(phi)*cos(theta) + L*theta_dot*cos(phi)*sin(theta)) - phi_dot*(L_dot*sin(phi)*sin(theta) + L*phi_dot*cos(phi)*sin(theta) + L*theta_dot*cos(theta)*sin(phi)) - L*cos(phi)*cos(theta)*(b*theta_dot - (phi_dot^2*sin(2*theta))/2 + (g*sin(theta))/L + (2*L_dot*theta_dot)/L) + L*sin(phi)*sin(theta)*(2*phi_dot*theta_dot*cot(theta) + (2*L_dot*phi_dot)/L)+...
	(cos(phi)*sin(phi) - cos(phi)*cos(theta)^2*sin(phi))* u(1,:) +...
	(- sin(phi)^2 - cos(phi)^2*cos(theta)^2)* u(2,:) + ...
	cos(phi)*sin(theta) * u(3,:);

ddy3 = L*sin(theta)*(b*theta_dot - (phi_dot^2*sin(2*theta))/2 + (g*sin(theta))/L + (2*L_dot*theta_dot)/L) - L_dot*theta_dot*sin(theta) - theta_dot*(L_dot*sin(theta) + L*theta_dot*cos(theta))+...
	cos(theta)*sin(phi)*sin(theta) * u(1,:) + ...
	cos(phi)*cos(theta)*sin(theta) * u(2,:) + ...
	cos(theta) *u(3,:);

% suffisso _lin per cercare retroazione linearizzante
upsi_lin = [ddy1; ddy2; ddy3]
upsi_lin = simplify(upsi_lin,5)
u_lin = -inv(E) * T + inv(E) * upsi_lin;
u_lin = simplify(u_lin,5)

zeta =[x_t; x_t_dot; y_t; y_t_dot]
zeta_dot = [jacobian(x_t,x)*(f + G*u);...
	jacobian(x_t_dot,x)*(f + G*u);...
	jacobian(y_t,x)*(f + G*u);...
	jacobian(y_t_dot,x)*(f + G*u)]

% % zeta_dot_mat = 
PHI_full = jacobian([Lf_full_mimo;zeta],x)
rank(PHI_full)

%
upsi_0	= subs(subs(upsi, x, x0), [b g], [1 9.81])
upsi_00 = eval(subs(upsi_0, u, [0;0;0]))
u_lin0	= eval(subs(subs(-inv(E) * T + inv(E) * upsi_00, x, x0), [b g], [1 9.81]) ) 


%% aumentiamo il sistema
syms x_t_ddot
x = [x;...
	 x_t_ddot]
f = [f+g1*x_t_ddot;...
		0]
g1 = [0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  1]
g2 = [g2;...
	   0]
g3 = [g3;...
	   0]
G = [g1 g2 g3];
[r_mimo,Lf_full_mimo, T, E] = relative_degree_mimo(f,G,y,x)
%% aumentiamo il sistema
syms y_t_ddot
x = [x;...
	 y_t_ddot]
f = [f+g2*y_t_ddot;...
		0]
g1 = [g1;...
	   0]
g2 = [0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  1]
 g3 = [g3;...
 	   0]
	G = [g1 g2 g3];
[r_mimo,Lf_full_mimo, T, E] = relative_degree_mimo(f,G,y,x)
%% aumentiamo il sistema
syms L_ddot
x = [x;...
	 L_ddot]
f = [f+g3*L_ddot;...
		0]
g1 = [g1;...
	   0]
g2 = [g2;...
   0]

g3 = [0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  0;...
	  1]
  
G = [g1 g2 g3];
[r_mimo,Lf_full_mimo, T, E] = relative_degree_mimo(f,G,y,x)
%%
% syms l_ddot
% x = [x;...
% 	 l_ddot]
% f = [f+g3*y_ddot;...
% 		0]
% g1 = [g1;...
% 	   0]
% g3 = [0;...
% 	  0;...
% 	  0;...
% 	  0;...
% 	  0;...
% 	  0;...
% 	  0;...
% 	  0;...
% 	  0;...
% 	  0;...
% 	  0;...
% 	  0;...
% 	  1]
%  g2 = [g2;...
% 		0]
% G = [g1 g2 g3];
% [r_mimo,Lf_full_mimo, T, E] = relative_degree_mimo(f,G,y,x)